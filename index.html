<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Explorer 3D - Premium Player</title>
    <style>
        :root {
            --primary: #ffaa00;
            --bg-dark: rgba(15, 15, 20, 0.95);
            --text-light: #f0f0f0;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            color: var(--text-light);
            -webkit-tap-highlight-color: transparent;
        }

        #game-canvas { display: block; width: 100vw; height: 100vh; }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD */
        .hud-top { padding: 15px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        .stat-box {
            background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px);
            padding: 8px 16px; border-radius: 12px; border-left: 3px solid var(--primary);
            font-weight: 700; font-size: 14px; margin-bottom: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); pointer-events: auto;
            text-shadow: 1px 1px 0 #000;
        }

        .btn-icon {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%; width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; pointer-events: auto; transition: all 0.2s;
            font-size: 20px;
        }
        .btn-icon:active { transform: scale(0.9); background: var(--primary); color: #000; }

        /* Target Info */
        #target-info {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 180px; text-align: center; opacity: 0; transition: opacity 0.2s;
        }
        .hp-bar-bg {
            background: rgba(0,0,0,0.5); height: 6px; border-radius: 3px;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.2); margin-top: 4px;
        }
        .hp-bar-fill { background: #ff4444; height: 100%; width: 100%; transition: width 0.1s; }

        /* Controls */
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 140px; height: 140px; pointer-events: auto; }
        .action-btn {
            position: absolute; background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; pointer-events: auto; backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.1s, border-color 0.1s;
            cursor: pointer;
        }
        .action-btn:active { background: rgba(255, 170, 0, 0.4); transform: scale(0.92); border-color: var(--primary); }
        #btn-break { bottom: 60px; right: 40px; width: 85px; height: 85px; background: rgba(255, 60, 60, 0.15); }
        #btn-shop { bottom: 170px; right: 40px; width: 50px; height: 50px; font-size: 20px; }

        /* Screens */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(10px);
            z-index: 100; display: flex; flex-direction: column;
            align-items: center; justify-content: center; pointer-events: auto;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 {
            color: var(--primary); font-size: 3.5rem; margin: 0 0 10px 0;
            text-shadow: 0 0 30px rgba(255, 170, 0, 0.4); text-align: center;
            letter-spacing: -2px; line-height: 0.9;
        }
        h2 { color: #fff; margin-bottom: 20px; border-bottom: 2px solid var(--primary); padding-bottom: 5px; letter-spacing: 1px; }

        .btn-main {
            background: linear-gradient(135deg, var(--primary), #cc8800);
            color: #000; font-size: 1.1rem; font-weight: 800;
            padding: 16px 45px; border: none; border-radius: 8px;
            cursor: pointer; margin: 10px; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s; text-transform: uppercase;
        }
        .btn-main:hover { transform: translateY(-2px); box-shadow: 0 15px 25px rgba(255, 170, 0, 0.2); }
        .btn-sec { background: #333; color: #fff; box-shadow: none; font-weight: 600; }

        /* Floating Text */
        .float-text {
            position: absolute; color: #fff; font-weight: 900; 
            font-size: 18px; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none; will-change: transform, opacity;
            top: 0; left: 0; display: none;
        }

        /* Shop Grid */
        .shop-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
            width: 90%; max-width: 500px; max-height: 50vh; overflow-y: auto; padding: 5px;
        }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            padding: 15px; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        .shop-item:hover { background: rgba(255,255,255,0.08); border-color: var(--primary); transform: translateY(-2px); }
        .item-price { float: right; color: #ffd700; font-weight: bold; }
        .item-name { color: var(--primary); font-weight: bold; margin-bottom: 4px; display: block; font-size: 0.95rem; }
        .item-desc { font-size: 0.75rem; color: #888; }


        .shop-header {
            grid-column: 1 / -1;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.07);
            color: #ddd;
            font-weight: 900;
            letter-spacing: 1px;
            font-size: 0.78rem;
            text-transform: uppercase;
        }

        /* Notifications */
        #notif-area {
            position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column-reverse; align-items: center; pointer-events: none;
        }
        .toast {
            background: rgba(20, 20, 20, 0.8); color: #fff; padding: 8px 16px;
            border-radius: 20px; margin-top: 8px; animation: floatUp 1.2s forwards;
            font-size: 0.9rem; border: 1px solid #444; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-weight: 600;
        }
        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(20px) scale(0.9); }
            10% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1); }
        }

        /* Settings Rows */
        .setting-row { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .setting-label { font-size: 0.9rem; color: #ddd; }
        select, input[type="checkbox"] { background: #222; color: white; border: 1px solid #444; padding: 5px; border-radius: 4px; }
        
        #low-fps-warning {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(200, 50, 0, 0.8); color: white; font-size: 10px;
            padding: 4px 10px; border-radius: 10px; pointer-events: none; opacity: 0; transition: opacity 0.5s;
        }
        /* Cinematic overlays (cheap, optional) */
        #fx-vignette, #fx-grain { position: absolute; inset: 0; pointer-events: none; z-index: 50; }
        #fx-vignette {
            background: radial-gradient(ellipse at center,
                rgba(0,0,0,0) 40%,
                rgba(0,0,0,0.2) 75%,
                rgba(0,0,0,0.5) 100%);
            mix-blend-mode: multiply;
            opacity: 0.2; /* Reduced for Day mode */
            transition: opacity 0.5s;
        }
        body.night-mode #fx-vignette { opacity: 0.85; }
        
        #fx-grain {
            opacity: 0.08;
            mix-blend-mode: overlay;
            background-image:
                repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 1px, rgba(0,0,0,0.04) 2px, rgba(0,0,0,0.04) 3px),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
            animation: grainMove 6s steps(10) infinite;
        }
        @keyframes grainMove {
            0% { transform: translate3d(0,0,0); }
            100% { transform: translate3d(-30px, 20px, 0); }
        }
        body.gfx-low #fx-grain { display: none; }
        body.gfx-low #fx-vignette { display: none; }

        /* First-person crosshair */
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            pointer-events: none;
            z-index: 60;
            opacity: 0;
            transition: opacity 0.15s;
        }
        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 0 10px rgba(255,170,0,0.35);
            transform: translate(-50%, -50%);
            border-radius: 2px;
        }
        #crosshair::before { width: 14px; height: 2px; }
        #crosshair::after  { width: 2px; height: 14px; }
        body.cam-fp #crosshair { opacity: 0.9; }

    </style>
<script type="importmap">
{
  "imports": {
    "vite": "https://esm.sh/vite@^7.3.1",
    "path": "https://esm.sh/path@^0.12.7"
  }
}
</script>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div id="fx-vignette"></div>
        <div id="fx-grain"></div>
        <div id="crosshair"></div>
        <!-- Floating Text Container -->
        <div id="float-container" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden;"></div>

        <!-- HUD -->
        <div id="hud" style="display:none;">
            <div id="low-fps-warning">‚ö†Ô∏è VFX Reduced due to low FPS</div>
            <div class="hud-top">
                <div class="stats-left">
                    <div class="stat-box">üíé <span id="val-crystals" style="color:#0ff">0</span></div>
                    <div class="stat-box">üì¶ <span id="val-mats" style="color:#da8">0</span></div>
                </div>
                <div class="stats-right">
                    <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-end;">
                        <div class="btn-icon" onclick="game.toggleCameraMode()" title="Camera">üëÅÔ∏è</div>
                        <div class="btn-icon" onclick="game.toggleSettings()" title="Settings">‚öôÔ∏è</div>
                    </div>
                </div>
            </div>

            <!-- Block HP -->
            <div id="target-info">
                <div id="target-name" style="font-size: 11px; font-weight: 800; letter-spacing:1px; text-transform:uppercase; color:#aaa;">BLOCK</div>
                <div class="hp-bar-bg"><div id="target-hp" class="hp-bar-fill"></div></div>
            </div>

            <!-- Controls -->
            <div id="joystick-zone"></div>
            <div id="btn-break" class="action-btn">‚õèÔ∏è</div>
            <div id="btn-shop" class="action-btn" onclick="game.toggleShop()">üõí</div>
        </div>

        <div id="notif-area"></div>
    </div>

    <!-- Start Screen -->
    <div id="screen-start" class="screen-overlay">
        <h1>VOXEL<br>EXPLORER</h1>
        <div style="font-size: 0.8rem; background:rgba(0,170,255,0.1); color:#0af; padding:4px 10px; border-radius:10px; margin-bottom:20px; border:1px solid rgba(0,170,255,0.3)">PREMIUM PLAYER UPDATE</div>
        <p style="color:#888; margin-bottom: 30px; font-size: 0.9rem;">Touch & Drag to Move ‚Ä¢ Tap to Mine</p>
        <button class="btn-main" onclick="game.start()">PLAY NOW</button>
        <button class="btn-main btn-sec" onclick="game.toggleSettings(true)">OPTIONS</button>
    </div>

    <!-- Shop Screen -->
    <div id="screen-shop" class="screen-overlay hidden">
        <h2>WORKSHOP</h2>
        <div style="margin-bottom: 15px; font-size: 1.05rem; display:flex; gap:14px; flex-wrap:wrap; justify-content:center;"><span style="background:rgba(0,255,255,0.06); border:1px solid rgba(0,255,255,0.18); padding:6px 10px; border-radius:12px;">üíé <span id="shop-balance" style="color:#0ff; font-weight:bold;">0</span></span><span style="background:rgba(255,170,0,0.06); border:1px solid rgba(255,170,0,0.18); padding:6px 10px; border-radius:12px;">üì¶ <span id="shop-balance-mats" style="color:#fb0; font-weight:bold;">0</span></span></div>
        <div class="shop-grid" id="shop-list"></div>
        <button class="btn-main btn-sec" onclick="game.toggleShop()">RESUME</button>
    </div>

    <!-- Settings Screen -->
    <div id="screen-settings" class="screen-overlay hidden">
        <h2>SETTINGS</h2>
        <div style="display:flex; flex-direction:column; gap:5px; width: 280px;">
            <div class="setting-row">
                <span class="setting-label">Graphics Quality</span>
                <select id="opt-quality">
                    <option value="LOW">Low (Fast)</option>
                    <option value="MED">Medium</option>
                    <option value="HIGH">High (Ultra)</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Time of Day</span>
                <select id="opt-time">
                    <option value="DAY">Day (Bright)</option>
                    <option value="NIGHT">Night (Dark)</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">VFX Level</span>
                <select id="opt-vfx">
                    <option value="LOW">Low</option>
                    <option value="MED">Medium</option>
                    <option value="HIGH">High</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Player Skin</span>
                <select id="opt-skin">
                    <option value="BLUE">Neon Blue</option>
                    <option value="RED">Magma Red</option>
                    <option value="GREEN">Toxic Green</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Visor Glow</span>
                <input type="checkbox" id="opt-glow" checked>
            </div>
            <div class="setting-row">
                <span class="setting-label">Shadows</span>
                <input type="checkbox" id="opt-shadows">
            </div>
            <div class="setting-row">
                <span class="setting-label">Bloom</span>
                <input type="checkbox" id="opt-bloom">
            </div>
             <div class="setting-row" style="border:none;">
                <span class="setting-label">Sound</span>
                <input type="checkbox" id="opt-sound">
            </div>
        </div>
        <div style="margin-top: 25px; display:flex; gap:10px;">
            <button class="btn-main btn-sec" onclick="game.toggleSettings()">APPLY & RESUME</button>
            <button class="btn-main btn-sec" style="background:#422" onclick="localStorage.clear(); location.reload()">RESET DATA</button>
        </div>
    </div>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { EffectComposer } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/OutputPass.js';

// =========================================
// UTILITIES
// =========================================
const CHUNK_SIZE = 16;
const RENDER_DIST = 2;

const COLORS = {
    DIRT: 0x8B5A2B,
    STONE: 0x888899,
    CRYSTAL: 0x00FFFF,
    MAGMA: 0xFF4400,
    GRASS: 0x55aa55,
    SPARK: 0xFFFFAA
};

const BLOCKS = {
    DIRT: { id: 1, hp: 30, color: COLORS.DIRT, name: "Dirt", rough: 0.9, metal: 0.1 },
    STONE: { id: 2, hp: 80, color: COLORS.STONE, name: "Stone", rough: 0.7, metal: 0.2 },
    CRYSTAL: { id: 3, hp: 130, color: COLORS.CRYSTAL, name: "Crystal", rough: 0.08, metal: 0.9, emit: 0.4 },
    MAGMA: { id: 4, hp: 55, color: COLORS.MAGMA, name: "Magma", rough: 0.35, metal: 0.5, emit: 0.6 },
};

const hash = (x, z) => { let n = Math.sin(x*12.9898 + z*78.233)*43758.5453; return n - Math.floor(n); };
const noise = (x, z) => {
    const fx=Math.floor(x), fz=Math.floor(z);
    const sx=x-fx, sz=z-fz;
    const a=hash(fx,fz), b=hash(fx+1,fz), c=hash(fx,fz+1), d=hash(fx+1,fz+1);
    return (a*(1-sx)+b*sx)*(1-sz) + (c*(1-sx)+d*sx)*sz;
};

// =========================================
// PROCEDURAL TEXTURES
// =========================================
function makeCanvasTexture({ size = 64, draw, repeat = 2, colorSpace = THREE.SRGBColorSpace } = {}) {
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const ctx = c.getContext('2d', { willReadFrequently: true });
    draw(ctx, size);

    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(repeat, repeat);
    tex.anisotropy = 4;
    tex.colorSpace = colorSpace;
    tex.needsUpdate = true;
    return { canvas: c, tex };
}

function makeNormalFromCanvas(canvas, strength = 2.0, repeat = 2) {
    const w = canvas.width, h = canvas.height;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const src = ctx.getImageData(0, 0, w, h).data;

    const out = new Uint8Array(w * h * 4);
    const getH = (x, y) => {
        x = (x + w) % w; y = (y + h) % h;
        const i = (y * w + x) * 4;
        return (src[i] * 0.2126 + src[i+1] * 0.7152 + src[i+2] * 0.0722) / 255;
    };

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const hl = getH(x - 1, y);
            const hr = getH(x + 1, y);
            const hu = getH(x, y - 1);
            const hd = getH(x, y + 1);

            const dx = (hr - hl) * strength;
            const dy = (hd - hu) * strength;

            let nx = -dx, ny = -dy, nz = 1.0;
            const invLen = 1.0 / Math.hypot(nx, ny, nz);
            nx *= invLen; ny *= invLen; nz *= invLen;

            const i = (y * w + x) * 4;
            out[i] = Math.round((nx * 0.5 + 0.5) * 255);
            out[i+1] = Math.round((ny * 0.5 + 0.5) * 255);
            out[i+2] = Math.round((nz * 0.5 + 0.5) * 255);
            out[i+3] = 255;
        }
    }

    const tex = new THREE.DataTexture(out, w, h, THREE.RGBAFormat);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(repeat, repeat);
    tex.anisotropy = 4;
    tex.colorSpace = THREE.NoColorSpace;
    tex.needsUpdate = true;
    return tex;
}

function makeSimpleEnvMap() {
    const mkFace = (top, bot) => {
        const c = document.createElement('canvas');
        c.width = c.height = 32;
        const ctx = c.getContext('2d');
        const g = ctx.createLinearGradient(0, 0, 0, 32);
        g.addColorStop(0, top);
        g.addColorStop(1, bot);
        ctx.fillStyle = g; ctx.fillRect(0, 0, 32, 32);
        return c;
    };
    const faces = [
        mkFace('#5aa7ff', '#0b1020'), mkFace('#5aa7ff', '#0b1020'),
        mkFace('#cfe8ff', '#3a4a66'), mkFace('#101020', '#000000'),
        mkFace('#5aa7ff', '#0b1020'), mkFace('#5aa7ff', '#0b1020'),
    ];
    const cube = new THREE.CubeTexture(faces);
    cube.colorSpace = THREE.SRGBColorSpace;
    cube.needsUpdate = true;
    return cube;
}

function createGameAssets(renderer) {
    const dirt = makeCanvasTexture({
        size: 64, repeat: 3,
        draw: (ctx, s) => {
            ctx.fillStyle = '#6b4123'; ctx.fillRect(0, 0, s, s);
            for (let i = 0; i < 900; i++) {
                const x = (Math.random() * s) | 0, y = (Math.random() * s) | 0;
                const v = 40 + (Math.random() * 60);
                ctx.fillStyle = `rgba(${v}, ${v*0.75}, ${v*0.35}, 0.35)`; ctx.fillRect(x, y, 1, 1);
            }
        }
    });
    const dirtN = makeNormalFromCanvas(dirt.canvas, 2.2, 3);

    const stone = makeCanvasTexture({
        size: 64, repeat: 3,
        draw: (ctx, s) => {
            ctx.fillStyle = '#6f7480'; ctx.fillRect(0, 0, s, s);
            for (let i=0;i<1200;i++){
                const x = (Math.random()*s)|0, y=(Math.random()*s)|0;
                const v = 110 + Math.random()*60;
                ctx.fillStyle = `rgba(${v},${v},${v+10},0.22)`; ctx.fillRect(x,y,1,1);
            }
        }
    });
    const stoneN = makeNormalFromCanvas(stone.canvas, 2.8, 3);

    const crystal = makeCanvasTexture({
        size: 64, repeat: 2,
        draw: (ctx, s) => {
            const g = ctx.createLinearGradient(0, 0, s, s);
            g.addColorStop(0, '#00eaff'); g.addColorStop(1, '#0066ff');
            ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }
    });
    const crystalN = makeNormalFromCanvas(crystal.canvas, 1.8, 2);

    const magma = makeCanvasTexture({
        size: 64, repeat: 2,
        draw: (ctx, s) => {
            ctx.fillStyle = '#1a0702'; ctx.fillRect(0,0,s,s);
            for(let i=0;i<200;i++){
                const x=Math.random()*s, y=Math.random()*s;
                const r=2+Math.random()*7;
                const grd=ctx.createRadialGradient(x,y,0,x,y,r);
                grd.addColorStop(0, 'rgba(255,170,40,0.9)');
                grd.addColorStop(1, 'rgba(90,10,0,0)');
                ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
            }
        }
    });
    const magmaN = makeNormalFromCanvas(magma.canvas, 2.4, 2);

    const ground = makeCanvasTexture({
        size: 128, repeat: 6,
        draw: (ctx, s) => {
            ctx.fillStyle = '#07070a'; ctx.fillRect(0,0,s,s);
            for(let i=0;i<2500;i++){
                const x=(Math.random()*s)|0,y=(Math.random()*s)|0;
                const v=18+Math.random()*30;
                ctx.fillStyle = `rgba(${v},${v},${v+5},0.35)`; ctx.fillRect(x,y,1,1);
            }
        }
    });
    const groundN = makeNormalFromCanvas(ground.canvas, 1.6, 6);

    const envMap = makeSimpleEnvMap();
    const blockGeo = new THREE.BoxGeometry(0.95, 0.95, 0.95);

    const blockMats = {};
    blockMats[1] = new THREE.MeshStandardMaterial({ color: COLORS.DIRT, map: dirt.tex, normalMap: dirtN, roughness: 0.95, metalness: 0.05, flatShading: true, vertexColors: true });
    blockMats[2] = new THREE.MeshStandardMaterial({ color: COLORS.STONE, map: stone.tex, normalMap: stoneN, roughness: 0.85, metalness: 0.1, flatShading: true, vertexColors: true });
    blockMats[3] = new THREE.MeshStandardMaterial({
        color: COLORS.CRYSTAL, map: crystal.tex, normalMap: crystalN, roughness: 0.12, metalness: 0.9,
        emissive: 0x00ccff, emissiveIntensity: 0.4, envMap, envMapIntensity: 0.5, flatShading: true, vertexColors: true, transparent: true, opacity: 0.98
    });
    blockMats[4] = new THREE.MeshStandardMaterial({
        color: COLORS.MAGMA, map: magma.tex, emissive: 0xff5500, emissiveMap: magma.tex, emissiveIntensity: 0.6, normalMap: magmaN, roughness: 0.55, metalness: 0.25, flatShading: true, vertexColors: true
    });

    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0a0a10, map: ground.tex, normalMap: groundN, roughness: 0.95, metalness: 0.02 });

    return { envMap, textures: { dirt: dirt.tex, stone: stone.tex, crystal: crystal.tex, magma: magma.tex, ground: ground.tex }, blockGeo, blockMats, groundMat, magmaTex: magma.tex };
}

// =========================================
// SYSTEMS
// =========================================

class AudioSys {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }
    resume() { if(this.ctx.state === 'suspended') this.ctx.resume(); }
    playTone(freq, type, dur, vol = 0.1) {
        if(!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.value = freq; osc.type = type;
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur);
    }
    hit() { this.playTone(100 + Math.random()*50, 'square', 0.05, 0.05); }
    break(type) { if(type === 3) this.playTone(600, 'sine', 0.4, 0.2); else this.playTone(80, 'sawtooth', 0.15, 0.2); }
    collect() { this.playTone(1200 + Math.random()*200, 'sine', 0.1, 0.1); }
}

class ParticleSys {
    constructor(scene, camera) {
        this.scene = scene; this.camera = camera;
        this.drops = []; this.texts = []; this.shockwaves = []; this.trails = []; this.ambient = null;
        this.MAX_PARTICLES = 1000;
        this.pools = { frags: { mesh: null, data: [], idx: 0 }, dust: { mesh: null, data: [], idx: 0 } };
        this.dummy = new THREE.Object3D();
        this.tempColor = new THREE.Color();
        this.tempVec = new THREE.Vector3();
        this.initInstancedPools();
        this.initLegacyPools();
        this.initAmbient();
    }

    initInstancedPools() {
        const fGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
        const fMat = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.2, vertexColors: true });
        this.pools.frags.mesh = new THREE.InstancedMesh(fGeo, fMat, this.MAX_PARTICLES);
        this.pools.frags.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.scene.add(this.pools.frags.mesh);

        const dGeo = new THREE.PlaneGeometry(0.1, 0.1);
        const dMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide, vertexColors: true });
        this.pools.dust.mesh = new THREE.InstancedMesh(dGeo, dMat, this.MAX_PARTICLES);
        this.pools.dust.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.scene.add(this.pools.dust.mesh);

        for(let i=0; i<this.MAX_PARTICLES; i++) {
            this.pools.frags.data.push({ pos: new THREE.Vector3(0,-100,0), vel: new THREE.Vector3(), rot: new THREE.Vector3(), rotVel: new THREE.Vector3(), life: 0, maxLife: 1, active: false });
            this.pools.dust.data.push({ pos: new THREE.Vector3(0,-100,0), vel: new THREE.Vector3(), life: 0, maxLife: 1, active: false });
            this.dummy.position.set(0, -100, 0); this.dummy.updateMatrix();
            this.pools.frags.mesh.setMatrixAt(i, this.dummy.matrix);
            this.pools.dust.mesh.setMatrixAt(i, this.dummy.matrix);
        }
    }

    initLegacyPools() {
        const sGeo = new THREE.RingGeometry(0.1, 0.6, 16);
        const sMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide});
        for(let i=0; i<5; i++) {
            const m = new THREE.Mesh(sGeo, sMat.clone()); m.rotation.x = -Math.PI/2; m.visible = false; this.scene.add(m);
            this.shockwaves.push({mesh: m, life: 0});
        }
        const dGeo = new THREE.OctahedronGeometry(0.25, 0);
        this.dropMatCrystal = new THREE.MeshStandardMaterial({ color: COLORS.CRYSTAL, map: game.assets.textures.crystal, roughness: 0.12, metalness: 0.95, emissive: 0x00ccff, emissiveIntensity: 0.4, envMap: game.assets.envMap, envMapIntensity: 0.5 });
        this.dropMatMat = new THREE.MeshStandardMaterial({ color: 0xffaa55, map: game.assets.textures.dirt, roughness: 0.9, metalness: 0.05, envMap: game.assets.envMap, envMapIntensity: 0.2 });
        for(let i=0; i<40; i++) {
            const m = new THREE.Mesh(dGeo, this.dropMatMat); m.visible = false; this.scene.add(m);
            this.drops.push({mesh: m, active: false, type: null, amount: 1});
        }
        const tGeo = new THREE.PlaneGeometry(0.6, 0.6);
        const tMat = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.3});
        for(let i=0; i<15; i++) {
            const m = new THREE.Mesh(tGeo, tMat.clone()); m.rotation.x = -Math.PI/2; m.visible = false; this.scene.add(m);
            this.trails.push({mesh: m, life: 0});
        }
        const container = document.getElementById('float-container');
        for(let i=0; i<10; i++) {
            const el = document.createElement('div'); el.className = 'float-text'; el.innerText = "+1";
            container.appendChild(el); this.texts.push({el: el, life: 0, wx:0, wz:0, wy:0});
        }
    }

    initAmbient() {
        const geo = new THREE.BufferGeometry();
        const pos = []; for(let i=0; i<30; i++) pos.push((Math.random()-0.5)*20, Math.random()*5, (Math.random()-0.5)*20);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({color: 0xffffaa, size: 0.15, transparent: true, opacity: 0.6});
        this.ambient = new THREE.Points(geo, mat); this.scene.add(this.ambient); this.ambient.visible = false;
    }

    spawn(poolName, pos, color, count, type) {
        const pool = this.pools[poolName]; if(!pool) return;
        for(let i=0; i<count; i++) {
            pool.idx = (pool.idx + 1) % this.MAX_PARTICLES;
            const p = pool.data[pool.idx];
            p.active = true; p.life = 1.0; p.maxLife = 0.5 + Math.random() * 0.5; p.pos.copy(pos).addScalar((Math.random()-0.5)*0.5);
            if(poolName === 'frags') {
                p.vel.set((Math.random()-0.5)*5, Math.random()*4 + 2, (Math.random()-0.5)*5);
                p.rot.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                p.rotVel.set((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
            } else {
                p.vel.set((Math.random()-0.5)*2, Math.random()*1.5, (Math.random()-0.5)*2);
                if(type === 'spark') p.vel.multiplyScalar(3);
            }
            this.tempColor.setHex(color); if(type === 'spark') this.tempColor.setHex(COLORS.SPARK);
            pool.mesh.setColorAt(pool.idx, this.tempColor);
        }
        pool.mesh.instanceColor.needsUpdate = true;
    }

    spawnBreakParticles(pos, blockDef) {
        const settings = game.settings.vfx;
        let fragCount = 0, dustCount = 0, shockwave = false, spark = false;
        if (settings === 'LOW') { dustCount = 5; }
        else if (settings === 'MED') { dustCount = 8; fragCount = 6; shockwave = true; }
        else { dustCount = 15; fragCount = 12; shockwave = true; spark = true; }

        if(blockDef.id === 1) { fragCount = Math.floor(fragCount * 0.5); dustCount = Math.floor(dustCount * 1.5); }
        else if (blockDef.id === 3) { if(spark) this.spawn('dust', pos, blockDef.color, 8, 'spark'); }
        else if (blockDef.id === 4) { if(spark) this.spawn('dust', pos, 0xFF4400, 8, 'spark'); }

        if(fragCount > 0) this.spawn('frags', pos, blockDef.color, fragCount, 'frag');
        if(dustCount > 0) this.spawn('dust', pos, blockDef.color, dustCount, 'dust');
        if(shockwave) {
            for(let s of this.shockwaves) {
                if(s.life <= 0) {
                    s.life = 1.0; s.mesh.position.copy(pos); s.mesh.position.y = 0.05; s.mesh.visible = true;
                    s.mesh.material.color.setHex(blockDef.color); s.mesh.scale.set(0.1,0.1,0.1); break;
                }
            }
        }
    }

    spawnDrop(pos, type, amount = 1) {
        for(let d of this.drops) {
            if(d.active) continue;
            d.active = true; d.type = type; d.amount = amount; d.mesh.position.copy(pos); d.mesh.visible = true;
            d.mesh.material = (type === 'crystal') ? this.dropMatCrystal : this.dropMatMat; return true;
        }
        return false;
    }

    spawnText(pos, msg, color) {
        for(let t of this.texts) {
            if(t.life <= 0) {
                t.life = 1.0; t.wx = pos.x; t.wy = pos.y + 1; t.wz = pos.z;
                t.el.innerText = msg; t.el.style.color = color; t.el.style.display = 'block'; break;
            }
        }
    }

    spawnTrail(pos) {
        if(game.settings.vfx === 'LOW') return;
        for(let t of this.trails) {
            if(t.life <= 0) {
                t.life = 0.5; t.mesh.position.copy(pos); t.mesh.position.y = 0.1; t.mesh.visible = true;
                t.mesh.material.opacity = 0.3; break;
            }
        }
    }

    update(dt, playerPos) {
        const vfx = game.settings.vfx;
        const poolF = this.pools.frags; let dirtyF = false;
        for(let i=0; i<this.MAX_PARTICLES; i++) {
            const p = poolF.data[i];
            if(p.active) {
                p.life -= dt;
                if(p.life <= 0) { p.active = false; this.dummy.position.set(0,-100,0); }
                else {
                    p.vel.y -= 15 * dt; p.pos.addScaledVector(p.vel, dt);
                    if(p.pos.y < 0) { p.pos.y = 0; p.vel.y *= -0.5; p.vel.x *= 0.7; p.vel.z *= 0.7; }
                    p.rot.x += p.rotVel.x * dt; p.rot.y += p.rotVel.y * dt;
                    this.dummy.position.copy(p.pos); this.dummy.rotation.set(p.rot.x, p.rot.y, p.rot.z);
                    this.dummy.scale.setScalar(p.life / p.maxLife);
                }
                this.dummy.updateMatrix(); poolF.mesh.setMatrixAt(i, this.dummy.matrix); dirtyF = true;
            }
        }
        if(dirtyF) poolF.mesh.instanceMatrix.needsUpdate = true;

        const poolD = this.pools.dust; let dirtyD = false;
        for(let i=0; i<this.MAX_PARTICLES; i++) {
            const p = poolD.data[i];
            if(p.active) {
                p.life -= dt;
                if(p.life <= 0) { p.active = false; this.dummy.position.set(0,-100,0); }
                else {
                    p.pos.addScaledVector(p.vel, dt); p.vel.multiplyScalar(0.95);
                    this.dummy.position.copy(p.pos); this.dummy.lookAt(this.camera.position);
                    this.dummy.scale.setScalar(p.life / p.maxLife);
                }
                this.dummy.updateMatrix(); poolD.mesh.setMatrixAt(i, this.dummy.matrix); dirtyD = true;
            }
        }
        if(dirtyD) poolD.mesh.instanceMatrix.needsUpdate = true;

        for(let s of this.shockwaves) { if(s.life > 0) { s.life -= dt * 3; s.mesh.visible = s.life > 0; if(s.mesh.visible) { const sc = 1 + (1-s.life) * 2; s.mesh.scale.set(sc, sc, sc); s.mesh.material.opacity = s.life * 0.5; } } }
        if(this.ambient) { this.ambient.visible = (vfx === 'HIGH'); if(this.ambient.visible) { this.ambient.position.x = playerPos.x; this.ambient.position.z = playerPos.z; this.ambient.rotation.y += dt * 0.1; } }
        for(let t of this.trails) { if(t.life > 0) { t.life -= dt; t.mesh.material.opacity = t.life * 0.4; t.mesh.scale.setScalar(1 - (0.5-t.life)); if(t.life <= 0) t.mesh.visible = false; } }

        const range = game.player.stats.magnet;
        for(let d of this.drops) {
            if(!d.active) continue;
            d.mesh.rotation.y += dt * 3; const bob = 0.5 + Math.sin(Date.now()*0.003)*0.15; d.mesh.position.y = bob;
            const dx = d.mesh.position.x - playerPos.x, dz = d.mesh.position.z - playerPos.z, distXZ = Math.hypot(dx, dz);
            if(distXZ < range) { this.tempVec.copy(playerPos); this.tempVec.y = bob; d.mesh.position.lerp(this.tempVec, dt*10); if(distXZ < 0.55) { d.active = false; d.mesh.visible = false; game.collect(d.type, d.mesh.position, d.amount); } }
        }

        if(this.texts.some(t => t.life > 0)) {
            const vec = new THREE.Vector3(); const wH = window.innerWidth / 2, hH = window.innerHeight / 2;
            for(let t of this.texts) { if(t.life > 0) { t.life -= dt; t.wy += dt * 1.5; vec.set(t.wx, t.wy, t.wz); vec.project(this.camera); const x = (vec.x * wH) + wH, y = -(vec.y * hH) + hH; t.el.style.transform = `translate3d(${x}px, ${y}px, 0)`; t.el.style.opacity = t.life; if(t.life <= 0) t.el.style.display = 'none'; } }
        }
    }
}

class Chunk {
    constructor(cx, cz, scene) {
        this.cx = cx; this.cz = cz; this.scene = scene;
        this.blocks = new Map(); this.meshes = {}; this.tempColor = new THREE.Color();
        this.generate(); this.build();
    }
    generate() {
        const sx = this.cx * CHUNK_SIZE, sz = this.cz * CHUNK_SIZE;
        for(let x=0; x<CHUNK_SIZE; x++) {
            for(let z=0; z<CHUNK_SIZE; z++) {
                const wx = sx + x, wz = sz + z; if(Math.abs(wx)<2 && Math.abs(wz)<2) continue;
                let n = noise(wx*0.1, wz*0.1), type = null;
                if(n > 0.6) type = BLOCKS.STONE; else if(n > 0.3) type = BLOCKS.DIRT;
                if(type && hash(wx, wz) > 0.945) type = BLOCKS.CRYSTAL;
                if(type && hash(wx, wz+100) > 0.992) type = BLOCKS.MAGMA;
                if(type) this.blocks.set(`${wx},${wz}`, { x: wx, z: wz, type: type.id, hp: type.hp, max: type.hp });
            }
        }
    }
    build() {
        const buckets = {}; this.blocks.forEach(b => { if(!buckets[b.type]) buckets[b.type] = []; buckets[b.type].push(b); });
        const geo = new THREE.BoxGeometry(0.95, 0.95, 0.95); const dummy = new THREE.Object3D(); const color = new THREE.Color();
        for(let [tid, list] of Object.entries(buckets)) {
            const def = Object.values(BLOCKS).find(d => d.id == tid);
            const mat = new THREE.MeshStandardMaterial({ color: def.color, roughness: def.rough, metalness: def.metal, emissive: def.emit ? def.color : 0x000000, emissiveIntensity: def.emit || 0 });
            const mesh = new THREE.InstancedMesh(geo, mat, list.length); mesh.castShadow = game.settings.shadows; mesh.receiveShadow = game.settings.shadows;
            mesh.userData = { chunk: this, typeId: Number(tid), instanceToX: new Int32Array(list.length), instanceToZ: new Int32Array(list.length) };
            list.forEach((b, i) => { dummy.position.set(b.x, 0, b.z); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); color.setHex(def.color); if(tid != 3 && tid != 4) { const r = (Math.random()-0.5)*0.1; color.r+=r; color.g+=r; color.b+=r; } mesh.setColorAt(i, color); b.baseColor = color.clone(); b.instanceId = i; mesh.userData.instanceToX[i] = b.x; mesh.userData.instanceToZ[i] = b.z; });
            this.scene.add(mesh); if (game && typeof game.addInteractable === 'function') game.addInteractable(mesh); this.meshes[tid] = mesh;
        }
    }
    hit(wx, wz, dmg) {
        const key = `${wx},${wz}`; const b = this.blocks.get(key); if(!b) return null;
        b.hp -= dmg; game.audio.hit(); const mesh = this.meshes[b.type]; const pct = b.hp / b.max;
        this.tempColor.setHex(0xffffff); mesh.setColorAt(b.instanceId, this.tempColor); mesh.instanceColor.needsUpdate = true;
        setTimeout(() => { if(this.blocks.has(key)) { const dC = b.baseColor.clone().multiplyScalar(0.4 + 0.6 * pct); if(pct < 0.3) dC.add(this.tempColor.setHex(0x550000)); mesh.setColorAt(b.instanceId, dC); mesh.instanceColor.needsUpdate = true; } }, 50);
        if(b.hp <= 0) {
            const dummy = new THREE.Object3D(); dummy.scale.set(0,0,0); dummy.updateMatrix(); mesh.setMatrixAt(b.instanceId, dummy.matrix); mesh.instanceMatrix.needsUpdate = true; this.blocks.delete(key); game.audio.break(b.type);
            if (game.pickTarget && game.pickTarget.x === wx && game.pickTarget.z === wz) game.pickTarget = null;
            const def = Object.values(BLOCKS).find(d => d.id == b.type); game.particles.spawnBreakParticles(new THREE.Vector3(wx, 0.5, wz), def); game.hitStop = 0.05;
            const dP = new THREE.Vector3(wx, 0.5, wz), yM = game.player.stats.yMat || 0, yC = game.player.stats.yCry || 0;
            if (b.type === 1) game.particles.spawnDrop(dP, 'mat', 1 + yM); else if (b.type === 2) game.particles.spawnDrop(dP, 'mat', 2 + yM); else if (b.type === 3) game.particles.spawnDrop(dP, 'crystal', 2 + yC); else if (b.type === 4) { game.particles.spawnDrop(dP, 'crystal', 4 + yC); game.particles.spawnDrop(dP, 'mat', 2 + yM); }
            if(b.type === 4) this.explode(wx, wz);
        }
        return b;
    }
    explode(ex, ez) { setTimeout(() => { for(let x=-1; x<=1; x++) for(let z=-1; z<=1; z++) { if(x===0 && z===0) continue; game.world.damageBlock(ex+x, ez+z, 999); } game.camera.shake(0.5); }, 150); }
    dispose() { Object.values(this.meshes).forEach(m => { if (game && typeof game.removeInteractable === 'function') game.removeInteractable(m); this.scene.remove(m); }); }
}

class World {
    constructor(scene) {
        this.scene = scene; this.chunks = new Map();
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), game.assets.groundMat);
        plane.rotation.x = -Math.PI/2; plane.position.y = -0.55; plane.receiveShadow = true; scene.add(plane);
    }
    update(px, pz) {
        const cx = Math.floor(px/CHUNK_SIZE), cz = Math.floor(pz/CHUNK_SIZE), keep = new Set();
        for(let x=-RENDER_DIST; x<=RENDER_DIST; x++) { for(let z=-RENDER_DIST; z<=RENDER_DIST; z++) { const key = `${cx+x},${cz+z}`; keep.add(key); if(!this.chunks.has(key)) this.chunks.set(key, new Chunk(cx+x, cz+z, this.scene)); } }
        for(let [key, chunk] of this.chunks) { if(!keep.has(key)) { chunk.dispose(); this.chunks.delete(key); } }
    }
    getBlock(x, z) { const c = this.chunks.get(`${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`); return c ? c.blocks.get(`${x},${z}`) : null; }
    damageBlock(x, z, amt) { const c = this.chunks.get(`${Math.floor(x/CHUNK_SIZE)},${Math.floor(z/CHUNK_SIZE)}`); return c ? c.hit(x, z, amt) : null; }
}

class Player {
    constructor(scene) {
        this.scene = scene; this.mesh = new THREE.Group(); this.model = new THREE.Group(); this.mesh.add(this.model);
        this.matBody = new THREE.MeshStandardMaterial({roughness: 0.3, metalness: 0.2}); this.matDark = new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.8}); this.matAccent = new THREE.MeshStandardMaterial({emissiveIntensity: 1.0});
        const bG = new THREE.CapsuleGeometry(0.22, 0.35, 4, 8); this.body = new THREE.Mesh(bG, this.matBody); this.body.position.y = 0.55; this.body.castShadow = true; this.model.add(this.body);
        this.head = new THREE.Group(); const hG = new THREE.BoxGeometry(0.28, 0.25, 0.3); const hM = new THREE.Mesh(hG, this.matBody); const vG = new THREE.BoxGeometry(0.22, 0.1, 0.05); this.visor = new THREE.Mesh(vG, this.matAccent); this.visor.position.set(0, 0, 0.155); this.head.add(hM, this.visor); this.head.position.y = 0.95; this.model.add(this.head);
        const pG = new THREE.BoxGeometry(0.3, 0.35, 0.15); this.pack = new THREE.Mesh(pG, this.matDark); this.pack.position.set(0, 0.65, -0.2); this.model.add(this.pack);
        const aG = new THREE.BoxGeometry(0.12, 0.25, 0.12); this.armL = new THREE.Mesh(aG, this.matBody); this.armL.position.set(-0.32, 0.6, 0); this.armR = new THREE.Mesh(aG, this.matBody); this.armR.position.set(0.32, 0.6, 0); this.model.add(this.armL, this.armR);
        const sG = new THREE.PlaneGeometry(1.2, 1.2); const sM = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.6 }); const cv = document.createElement('canvas'); cv.width=cv.height=64; const cx = cv.getContext('2d'); const gr = cx.createRadialGradient(32,32,0,32,32,32); gr.addColorStop(0, 'rgba(0,0,0,1)'); gr.addColorStop(1, 'rgba(0,0,0,0)'); cx.fillStyle = gr; cx.fillRect(0,0,64,64); sM.map = sM.alphaMap = new THREE.CanvasTexture(cv); this.shadow = new THREE.Mesh(sG, sM); this.shadow.rotation.x = -Math.PI/2; this.shadow.position.y = 0.02; this.mesh.add(this.shadow);
        scene.add(this.mesh); this.pos = this.mesh.position; this.rot = this.mesh.rotation; this.stats = { dmg: 20, speed: 6, magnet: 4.5, cd: 0.25, mineRange: 3.25, yMat: 0, yCry: 0 }; this.time = 0; this.recoil = 0; this.trailTimer = 0; this.cdTimer = 0;
        this.skins = { BLUE: { body: 0x224488, accent: 0x00ffff }, RED: { body: 0x882222, accent: 0xff4400 }, GREEN: { body: 0x226622, accent: 0x44ff00 } }; this.currentSkin = 'BLUE';
    }
    setSkin(id, glow) { if(this.skins[id]) { this.currentSkin = id; const s = this.skins[id]; this.matBody.color.setHex(s.body); this.matAccent.color.setHex(s.accent); this.matAccent.emissive.setHex(s.accent); this.matAccent.emissiveIntensity = glow ? 1.5 : 0; } }
    pulse() { this.matAccent.emissiveIntensity = 3.0; setTimeout(() => this.matAccent.emissiveIntensity = game.settings.glow ? 1.5 : 0, 150); }
    update(dt, input, world) {
        this.time += dt; const moving = input.move.lengthSq() > 0.01;
        if(moving) { const ang = Math.atan2(input.move.x, input.move.y); let diff = ang - this.rot.y; while(diff > Math.PI) diff -= Math.PI*2; while(diff < -Math.PI) diff += Math.PI*2; this.rot.y += diff * 12 * dt; const spd = this.stats.speed * dt; const nx = this.pos.x + Math.sin(this.rot.y) * spd, nz = this.pos.z + Math.cos(this.rot.y) * spd; if(!world.getBlock(Math.round(nx), Math.round(this.pos.z))) this.pos.x = nx; if(!world.getBlock(Math.round(this.pos.x), Math.round(nz))) this.pos.z = nz; this.model.position.y = Math.sin(this.time * 15) * 0.03; this.armL.rotation.x = Math.sin(this.time * 15) * 0.5; this.armR.rotation.x = -Math.sin(this.time * 15) * 0.5; this.model.rotation.x = THREE.MathUtils.lerp(this.model.rotation.x, 0.15, dt * 5); this.trailTimer += dt; if(this.trailTimer > 0.1) { game.particles.spawnTrail(this.pos); this.trailTimer = 0; } }
        else { this.model.position.y = Math.sin(this.time * 2) * 0.01; this.armL.rotation.x = THREE.MathUtils.lerp(this.armL.rotation.x, 0, dt*5); this.armR.rotation.x = THREE.MathUtils.lerp(this.armR.rotation.x, 0, dt*5); this.model.rotation.x = THREE.MathUtils.lerp(this.model.rotation.x, 0, dt * 5); }
        if(this.cdTimer > 0) this.cdTimer -= dt; let tx, tz, target; const pick = game.pickTarget; if(pick && pick.block) { tx = pick.x; tz = pick.z; target = pick.block; } else { tx = Math.round(this.pos.x + Math.sin(this.rot.y)); tz = Math.round(this.pos.z + Math.cos(this.rot.y)); target = world.getBlock(tx, tz); }
        game.ui.updateTarget(target, tx, tz); if(this.recoil > 0) { this.recoil -= dt * 5; this.model.rotation.x -= this.recoil * 0.2; }
        if(input.action && this.cdTimer <= 0) { this.cdTimer = this.stats.cd; this.recoil = 1.0; if(target) { const res = world.damageBlock(tx, tz, this.stats.dmg); if(res && res.hp <= 0) game.ui.updateTarget(null); game.camera.shake(0.2); } else { game.camera.shake(0.05); } }
    }
}

class Game {
    constructor() {
        this.res = { cry: 0, mat: 0 }; const isMob = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); this.isMobile = isMob;
        this.settings = { quality: isMob ? 'LOW' : 'HIGH', shadows: !isMob, bloom: !isMob, vfx: isMob ? 'LOW' : 'HIGH', sound: true, skin: 'BLUE', glow: true, cam: 'TOP', time: 'DAY' };
        this.camMode = 'TOP'; this.hitStop = 0; this.interactables = []; this.raycaster = new THREE.Raycaster(); this.pointerNDC = new THREE.Vector2(0, 0); this.pointerActive = false; this.pickTarget = null; this.maxMineRange = 3.25; this.fpsHistory = []; this.running = false; this.started = false;
        this._v1 = new THREE.Vector3(); this._v2 = new THREE.Vector3(); this._v3 = new THREE.Vector3(); this._v4 = new THREE.Vector3(); this._v5 = new THREE.Vector3(); this.look = { active: false, pid: -1, lastX: 0 };
        this.initThree(); this.initInput(); this.load(); this.loadPreset(this.settings.quality); this.setCameraMode(this.settings.cam || 'TOP', true); this.setTimeOfDay(this.settings.time || 'DAY');
    }

    setCameraMode(m, s = false) { this.camMode = m; this.settings.cam = m; document.body.classList.toggle('cam-fp', m === 'FP'); this.cameraObj.fov = (m === 'FP') ? 72 : 55; this.cameraObj.updateProjectionMatrix(); if (m === 'FP') { this.pointerActive = true; this.pointerNDC.set(0, 0); } else { this.pointerActive = false; this.pickTarget = null; } if (this.player) this.player.model.visible = (m !== 'FP'); if (!s && this.ui) this.ui.notify(m === 'FP' ? 'FIRST PERSON' : 'TOP VIEW'); this.save(); }
    toggleCameraMode() { this.setCameraMode(this.camMode === 'FP' ? 'TOP' : 'FP'); }
    setTimeOfDay(t) {
        this.settings.time = t; const isD = (t === 'DAY'); document.body.classList.toggle('night-mode', !isD);
        if (isD) { this.scene.background = new THREE.Color(0x88ccee); this.scene.fog = new THREE.FogExp2(0x88ccee, 0.015); this.sun.color.setHex(0xffffff); this.sun.intensity = 1.4; this.hemiLight.color.setHex(0xffffff); this.hemiLight.groundColor.setHex(0x666666); this.hemiLight.intensity = 0.65; }
        else { this.scene.background = new THREE.Color(0x050508); this.scene.fog = new THREE.FogExp2(0x050508, 0.05); this.sun.color.setHex(0xffdfba); this.sun.intensity = 1.2; this.hemiLight.color.setHex(0xaaccff); this.hemiLight.groundColor.setHex(0x444444); this.hemiLight.intensity = 0.4; }
        this.save();
    }
    loadPreset(m) { this.settings.quality = m; document.body.classList.toggle('gfx-low', m === 'LOW'); if(m === 'LOW') { this.settings.shadows=false; this.settings.bloom=false; this.settings.vfx='LOW'; this.renderer.setPixelRatio(1.0); } if(m === 'MED') { this.settings.shadows=true; this.settings.bloom=false; this.settings.vfx='MED'; this.renderer.setPixelRatio(1.2); } if(m === 'HIGH') { this.settings.shadows=true; this.settings.bloom=true; this.settings.vfx='HIGH'; this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); } this.updateGraphics(); }
    updateGraphics() {
        this.renderer.shadowMap.enabled = this.settings.shadows; if(this.sun) this.sun.castShadow = this.settings.shadows; for(const m of this.interactables) { m.castShadow = this.settings.shadows; m.receiveShadow = this.settings.shadows; }
        if(this.settings.bloom) { if(!this.composer) { this.composer = new EffectComposer(this.renderer); this.composer.addPass(new RenderPass(this.scene, this.cameraObj)); const s = (this.settings.quality === 'HIGH') ? 0.45 : 0.3, r = (this.settings.quality === 'HIGH') ? 0.4 : 0.3, th = 0.85; this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), s, r, th)); this.composer.addPass(new OutputPass()); } } else { this.composer = null; }
    }
    addInteractable(m) { this.interactables.push(m); }
    removeInteractable(m) { const i = this.interactables.indexOf(m); if (i >= 0) this.interactables.splice(i, 1); }
    setPointerFromClient(x, y) { this.pointerNDC.set((x / window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1); this.pointerActive = true; }
    updatePickTarget() { this.pickTarget = null; if (!this.player || this.interactables.length === 0) return; if (this.camMode === 'FP') { this.pointerActive = true; this.pointerNDC.set(0, 0); } if (!this.pointerActive) return; this.raycaster.setFromCamera(this.pointerNDC, this.cameraObj); const hits = this.raycaster.intersectObjects(this.interactables, false); for (const h of hits) { if (h.instanceId === undefined) continue; const mesh = h.object; const c = mesh.userData.chunk, itx = mesh.userData.instanceToX, itz = mesh.userData.instanceToZ; if (!c || !itx || !itz) continue; const x = itx[h.instanceId], z = itz[h.instanceId], b = c.blocks.get(`${x},${z}`); if (!b) continue; const dx = x - this.player.pos.x, dz = z - this.player.pos.z; if (dx*dx + dz*dz > this.maxMineRange * this.maxMineRange) continue; this.pickTarget = { x, z, block: b }; return; } }

    initThree() {
        this.scene = new THREE.Scene(); this.cameraObj = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 60); this.camOffset = new THREE.Vector3(0, 11, 8); this.camShake = 0;
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: !this.isMobile, powerPreference: "high-performance" }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.toneMapping = THREE.ACESFilmicToneMapping; this.renderer.toneMappingExposure = 0.9; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.assets = createGameAssets(this.renderer); this.hemiLight = new THREE.HemisphereLight(0xaaccff, 0x444444, 0.4); this.scene.add(this.hemiLight); this.sun = new THREE.DirectionalLight(0xffdfba, 1.2); this.sun.position.set(15, 25, 10); this.sun.shadow.mapSize.width = this.sun.shadow.mapSize.height = 1024; const d = 25; this.sun.shadow.camera.left = -d; this.sun.shadow.camera.right = d; this.sun.shadow.camera.top = d; this.sun.shadow.camera.bottom = -d; this.sun.shadow.bias = -0.0005; this.scene.add(this.sun); this.playerLight = new THREE.PointLight(0xffaa00, 0.5, 10); this.scene.add(this.playerLight); this.targetBox = new THREE.Mesh(new THREE.BoxGeometry(1.05, 1.05, 1.05), new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, transparent:true, opacity:0.3})); this.scene.add(this.targetBox);
        window.addEventListener('resize', () => { this.cameraObj.aspect = window.innerWidth/window.innerHeight; this.cameraObj.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); if(this.composer) this.composer.setSize(window.innerWidth, window.innerHeight); });
    }

    initInput() {
        this.input = { move: new THREE.Vector2(), action: false }; const zone = document.getElementById('joystick-zone'); let jB = null;
        const hI = (x, y, t) => { if(t === 'end') { this.input.move.set(0,0); if(jB) { jB.remove(); jB=null; } return; } if(t === 'start') { this.jOrigin = {x, y}; jB = document.createElement('div'); jB.style.cssText = `position:absolute; width:40px; height:40px; background:rgba(255,255,255,0.3); border-radius:50%; left:${x-20}px; top:${y-20}px; pointer-events:none; z-index:999;`; document.body.appendChild(jB); } const dx = x - this.jOrigin.x, dy = y - this.jOrigin.y, dist = Math.min(Math.hypot(dx,dy), 50), ang = Math.atan2(dy,dx); this.input.move.set(Math.cos(ang)*dist/50, Math.sin(ang)*dist/50); if(jB) { jB.style.left = (this.jOrigin.x + this.input.move.x * 50 - 20)+'px'; jB.style.top = (this.jOrigin.y + this.input.move.y * 50 - 20)+'px'; } };
        zone.addEventListener('touchstart', e => { e.preventDefault(); hI(e.changedTouches[0].clientX, e.changedTouches[0].clientY, 'start'); });
        zone.addEventListener('touchmove', e => { e.preventDefault(); hI(e.changedTouches[0].clientX, e.changedTouches[0].clientY, 'move'); });
        document.addEventListener('touchend', e => { hI(0, 0, 'end'); }); document.addEventListener('mouseup', e => { if (this.input.move.lengthSq() > 0) hI(0, 0, 'end'); });
        let isD = false; zone.addEventListener('mousedown', e => { isD = true; hI(e.clientX, e.clientY, 'start'); }); window.addEventListener('mousemove', e => { if(isD) hI(e.clientX, e.clientY, 'move'); }); window.addEventListener('mouseup', e => { if(isD) { isD = false; hI(0, 0, 'end'); } });
        const btn = document.getElementById('btn-break'), setA = (s) => this.input.action = s; btn.addEventListener('touchstart', e => { e.preventDefault(); setA(true); }); btn.addEventListener('touchend', e => { e.preventDefault(); setA(false); }); btn.addEventListener('mousedown', () => setA(true)); window.addEventListener('mouseup', () => setA(false));
        const canvas = this.renderer.domElement; canvas.addEventListener('pointerdown', (e) => { if(!this.started || (e.pointerType === 'mouse' && e.button !== 0)) return; if(this.camMode === 'FP') { if(e.clientX > window.innerWidth * 0.35) { this.look.active = true; this.look.pid = e.pointerId; this.look.lastX = e.clientX; try { canvas.setPointerCapture(e.pointerId); } catch(_) {} } return; } this.setPointerFromClient(e.clientX, e.clientY); }, {passive:true}); canvas.addEventListener('pointermove', (e) => { if(!this.started) return; if(this.camMode === 'FP') { if(this.look.active && e.pointerId === this.look.pid && this.player) { const dx = e.clientX - this.look.lastX; this.look.lastX = e.clientX; const s = (e.pointerType === 'mouse') ? 0.004 : 0.007; this.player.rot.y -= dx * s; } return; } if(e.pointerType === 'mouse' && (e.buttons & 1)) this.setPointerFromClient(e.clientX, e.clientY); }, {passive:true});
        canvas.addEventListener('pointerup', (e) => { if(this.look.active && e.pointerId === this.look.pid) { this.look.active = false; this.look.pid = -1; } }, {passive:true});
        document.getElementById('btn-shop').addEventListener('touchstart', e => { e.preventDefault(); this.toggleShop(); });
        const keys = {}; window.addEventListener('keydown', e => { keys[e.code] = true; this.updateKeys(keys); if(e.code === 'Space') this.input.action = true; }); window.addEventListener('keyup', e => { keys[e.code] = false; this.updateKeys(keys); if(e.code === 'Space') this.input.action = false; });
    }

    updateKeys(keys) { this.input.move.set(0,0); if(keys['KeyW']) this.input.move.y = -1; if(keys['KeyS']) this.input.move.y = 1; if(keys['KeyA']) this.input.move.x = -1; if(keys['KeyD']) this.input.move.x = 1; if(this.input.move.length() > 0) this.input.move.normalize(); }
    start() { this.audio = new AudioSys(); this.audio.enabled = this.settings.sound; this.audio.resume(); this.world = new World(this.scene); this.player = new Player(this.scene); try { const s = JSON.parse(localStorage.getItem('vx_stats_hd')); if(s) this.player.stats = { ...this.player.stats, ...s }; } catch(e) {} if(this.player.stats.mineRange) this.maxMineRange = this.player.stats.mineRange; this.player.setSkin(this.settings.skin, this.settings.glow); this.setCameraMode(this.settings.cam || 'TOP', true); this.particles = new ParticleSys(this.scene, this.cameraObj); document.getElementById('screen-start').classList.add('hidden'); document.getElementById('hud').style.display = 'block'; this.ui = { c: document.getElementById('val-crystals'), m: document.getElementById('val-mats'), tInfo: document.getElementById('target-info'), tName: document.getElementById('target-name'), tHp: document.getElementById('target-hp'), updateTarget: (b, x, z) => { if(b) { this.targetBox.visible = true; this.targetBox.position.set(x, 0, z); this.ui.tInfo.style.opacity = 1; const d = Object.values(BLOCKS).find(d => d.id == b.type); this.ui.tName.innerText = d.name; this.ui.tHp.style.width = (b.hp/b.max)*100 + "%"; } else { this.targetBox.visible = false; this.ui.tInfo.style.opacity = 0; } }, notify: (msg) => { const el = document.createElement('div'); el.className = 'toast'; el.innerText = msg; document.getElementById('notif-area').appendChild(el); setTimeout(()=>el.remove(), 1600); } }; this.updateResUI(); this.started = true; this.running = true; this.loop(); }
    collect(t, p, a = 1) { this.audio.collect(); if(t === 'crystal') { this.res.cry += a; this.particles.spawnText(p, `+${a} Crystal${a>1?'s':''}`, "#0ff"); } else { this.res.mat += a; this.particles.spawnText(p, `+${a} Mat${a>1?'s':''}`, "#fb0"); } this.player.pulse(); this.updateResUI(); this.save(); }
    updateResUI() { this.ui.c.innerText = this.res.cry; this.ui.m.innerText = this.res.mat; }
    updateCam(dt) { if (!this.player) return; if (this.camMode === 'FP') { const yaw = this.player.rot.y, fwd = this._v1.set(Math.sin(yaw), 0, Math.cos(yaw)), head = this._v2.copy(this.player.pos).add(this._v3.set(0, 1.05, 0)), camPos = this._v4.copy(head).addScaledVector(fwd, 0.12); if (this.camShake > 0) { camPos.x += (Math.random() - 0.5) * this.camShake; camPos.y += (Math.random() - 0.5) * this.camShake * 0.35; camPos.z += (Math.random() - 0.5) * this.camShake; this.camShake = Math.max(0, this.camShake - dt * 3); } this.cameraObj.position.lerp(camPos, 10 * dt); this.cameraObj.lookAt(this._v5.copy(this.cameraObj.position).addScaledVector(fwd, 10).add(this._v3.set(0, -0.10, 0))); } else { const t = this._v4.copy(this.player.pos).add(this.camOffset); if (this.camShake > 0) { t.x += (Math.random() - 0.5) * this.camShake; t.z += (Math.random() - 0.5) * this.camShake; this.camShake = Math.max(0, this.camShake - dt * 3); } this.cameraObj.position.lerp(t, 5 * dt); this.cameraObj.lookAt(this.player.pos); } this.sun.position.set(this.player.pos.x + 15, 25, this.player.pos.z + 10); this.sun.target = this.player.mesh; this.playerLight.position.copy(this.player.pos).addScalar(0.5); }
    camera = { shake: (amt) => this.camShake = amt };
    toggleSettings(f) { const el = document.getElementById('screen-settings'); if(!el.classList.contains('hidden') || f) { el.classList.remove('hidden'); this.running = false; } else { el.classList.add('hidden'); if(this.started) { this.running = true; this.loop(); } } document.getElementById('opt-quality').value = this.settings.quality; document.getElementById('opt-time').value = this.settings.time; document.getElementById('opt-vfx').value = this.settings.vfx; document.getElementById('opt-bloom').checked = this.settings.bloom; document.getElementById('opt-shadows').checked = this.settings.shadows; document.getElementById('opt-sound').checked = this.settings.sound; document.getElementById('opt-skin').value = this.settings.skin; document.getElementById('opt-glow').checked = this.settings.glow; document.getElementById('opt-quality').onchange = (e) => this.loadPreset(e.target.value); document.getElementById('opt-time').onchange = (e) => this.setTimeOfDay(e.target.value); document.getElementById('opt-vfx').onchange = (e) => this.settings.vfx = e.target.value; document.getElementById('opt-bloom').onchange = (e) => { this.settings.bloom = e.target.checked; this.updateGraphics(); }; document.getElementById('opt-shadows').onchange = (e) => { this.settings.shadows = e.target.checked; this.updateGraphics(); }; document.getElementById('opt-sound').onchange = (e) => { this.settings.sound = e.target.checked; this.audio.enabled = e.target.checked; }; document.getElementById('opt-skin').onchange = (e) => { this.settings.skin = e.target.value; if(this.player) this.player.setSkin(e.target.value, this.settings.glow); }; document.getElementById('opt-glow').onchange = (e) => { this.settings.glow = e.target.checked; if(this.player) this.player.setSkin(this.settings.skin, e.target.checked); }; this.save(); }
    toggleShop() { const el = document.getElementById('screen-shop'); if(el.classList.contains('hidden')) { el.classList.remove('hidden'); this.running = false; this.renderShop(); } else { el.classList.add('hidden'); this.running = true; this.loop(); } }
    renderShop() {
        const list = document.getElementById('shop-list'); document.getElementById('shop-balance').innerText = this.res.cry; document.getElementById('shop-balance-mats').innerText = this.res.mat; list.innerHTML = ''; const s = this.player.stats;
        const lD = Math.max(0, Math.round((s.dmg - 20) / 10)), lS = Math.max(0, Math.round((s.speed - 6) / 0.6)), lM = Math.max(0, Math.round((s.magnet - 4.5) / 0.6)), lC = Math.max(0, Math.round((0.25 - s.cd) / 0.02)), lR = Math.max(0, Math.round((s.mineRange - 3.25) / 0.5));
        const head = (t) => { const h = document.createElement('div'); h.className = 'shop-header'; h.innerText = t; list.appendChild(h); };
        const costT = (c) => { const p = []; if(c.cry) p.push(`${c.cry} üíé`); if(c.mat) p.push(`${c.mat} üì¶`); return p.join(' + '); };
        const canA = (c) => (this.res.cry >= (c.cry||0)) && (this.res.mat >= (c.mat||0));
        const addItem = ({ name, desc, cost, cur, onBuy }) => { const el = document.createElement('div'); el.className = 'shop-item'; el.innerHTML = `<span class="item-price">${costT(cost)}</span><span class="item-name">${name}</span><div class="item-desc">${desc} <span style="color:#666">| ${cur}</span></div>`; el.onclick = () => { if(!canA(cost)) { this.ui.notify("NOT ENOUGH RESOURCES"); return; } this.res.cry -= (cost.cry||0); this.res.mat -= (cost.mat||0); onBuy(); this.ui.notify("PURCHASED"); this.updateResUI(); this.save(); this.renderShop(); }; list.appendChild(el); };
        head("Core Upgrades");
        addItem({ name: "TITANIUM PICK", desc: "More damage", cost: { mat: 12 + lD * 10 }, cur: `DMG ${s.dmg}`, onBuy: () => { s.dmg += 10; } });
        addItem({ name: "TURBO BOOTS", desc: "Move faster", cost: { mat: 14 + lS * 12 }, cur: `SPD ${s.speed.toFixed(1)}`, onBuy: () => { s.speed += 0.6; } });
        addItem({ name: "MAGNET CORE", desc: "Radius", cost: { mat: 12 + lM * 12 }, cur: `MAG ${s.magnet.toFixed(1)}`, onBuy: () => { s.magnet += 0.6; } });
        addItem({ name: "COOLDOWN CHIP", desc: "Mine faster", cost: { mat: 18 + lC * 14 }, cur: `CD ${s.cd.toFixed(2)}s`, onBuy: () => { s.cd = Math.max(s.cd - 0.02, 0.1); } });
        addItem({ name: "RANGE LENS", desc: "Mine farther", cost: { mat: 16 + lR * 14 }, cur: `RNG ${s.mineRange.toFixed(2)}`, onBuy: () => { s.mineRange = Math.min(s.mineRange + 0.5, 6); this.maxMineRange = s.mineRange; } });
        head("Trades");
        addItem({ name: "REFINE MATERIALS", desc: "Trade 10 mats ‚ûú +2 crystals", cost: { mat: 10 }, cur: "Trade", onBuy: () => { this.res.cry += 2; } });
        addItem({ name: "SUPPLY CRATE", desc: "Trade 5 crystals ‚ûú +30 mats", cost: { cry: 5 }, cur: "Trade", onBuy: () => { this.res.mat += 30; } });
    }
    save() { try { localStorage.setItem('vx_data_hd', JSON.stringify({res:this.res, set:this.settings})); if(this.player) localStorage.setItem('vx_stats_hd', JSON.stringify(this.player.stats)); } catch(e) {} }
    load() { try { const d = JSON.parse(localStorage.getItem('vx_data_hd')); if(d) { this.res = d.res; this.settings = {...this.settings, ...d.set}; } } catch(e) {} }
    monitorFPS(dt) { if(dt > 0) this.fpsHistory.push(1/dt); if(this.fpsHistory.length > 60) this.fpsHistory.shift(); if(this.fpsHistory.length >= 60) { const avg = this.fpsHistory.reduce((a,b)=>a+b)/60; if(avg < 30 && this.settings.vfx !== 'LOW') { this.settings.vfx = 'LOW'; document.getElementById('opt-vfx').value = 'LOW'; const el = document.getElementById('low-fps-warning'); el.style.opacity = 1; setTimeout(()=>el.style.opacity=0, 3000); this.fpsHistory = []; } } }
    loop() { if(!this.running) return; requestAnimationFrame(() => this.loop()); if(!this.player || !this.world || !this.particles) return; let dt = Math.min(this.clock.getDelta(), 0.1); if(this.hitStop > 0) { this.hitStop -= dt; if(this.hitStop > 0) return; } this.monitorFPS(dt); if(this.assets && this.assets.magmaTex) { this.assets.magmaTex.offset.x = (this.assets.magmaTex.offset.x + dt * 0.05) % 1; this.assets.magmaTex.offset.y = (this.assets.magmaTex.offset.y + dt * 0.03) % 1; } this.updatePickTarget(); this.player.update(dt, this.input, this.world); this.world.update(this.player.pos.x, this.player.pos.z); this.particles.update(dt, this.player.pos); this.updateCam(dt); if(this.composer) this.composer.render(); else this.renderer.render(this.scene, this.cameraObj); }
}
const game = new Game(); window.game = game; game.clock = new THREE.Clock();
</script>
</body>
</html>